(function(definition){var TiledActionProvider=definition(typeof Parallelio!=="undefined"?Parallelio:this.Parallelio);TiledActionProvider.definition=definition;if(typeof module!=="undefined"&&module!==null){module.exports=TiledActionProvider;}else{if(typeof Parallelio!=="undefined"&&Parallelio!==null){Parallelio.TiledActionProvider=TiledActionProvider;}else{if(this.Parallelio==null){this.Parallelio={};}this.Parallelio.TiledActionProvider=TiledActionProvider;}}})(function(dependencies){if(dependencies==null){dependencies={};}
var ActionProvider = dependencies.hasOwnProperty("ActionProvider") ? dependencies.ActionProvider : require('./ActionProvider');
var Mixable = dependencies.hasOwnProperty("Mixable") ? dependencies.Mixable : require('spark-starter').Mixable;
var TiledActionProvider;
TiledActionProvider = (function() {
  class TiledActionProvider extends ActionProvider {
    validActionTile(tile) {
      return tile != null;
    }

    prepareActionTile(tile) {
      if (!tile.getPropertyInstance('providedActions')) {
        return Mixable.Extension.make(ActionProvider.prototype, tile);
      }
    }

  };

  TiledActionProvider.properties({
    tile: {
      change: function(old, overrided) {
        overrided(old);
        return this.forwardedActions;
      }
    },
    actionTiles: {
      collection: true,
      calcul: function(invalidator) {
        var myTile;
        myTile = invalidator.prop('tile');
        if (myTile) {
          return this.actionTilesCoord.map((coord) => {
            return myTile.getRelativeTile(coord.x, coord.y);
          }).filter((tile) => {
            return this.validActionTile(tile);
          });
        } else {
          return [];
        }
      }
    },
    forwardedActions: {
      collection: {
        compare: function(a, b) {
          return a.action === b.action && a.location === b.location;
        }
      },
      calcul: function(invalidator) {
        var actionTiles, actions;
        actionTiles = invalidator.prop('actionTiles');
        actions = invalidator.prop('providedActions');
        return actionTiles.reduce((res, tile) => {
          return res.concat(actions.map(function(act) {
            return {
              action: act,
              location: tile
            };
          }));
        }, []);
      },
      itemAdded: function(forwarded) {
        this.prepareActionTile(forwarded.location);
        return forwarded.location.providedActions.add(forwarded.action);
      },
      itemRemoved: function(forwarded) {
        return forwarded.location.providedActions.remove(forwarded.action);
      }
    }
  });

  TiledActionProvider.prototype.actionTilesCoord = [
    {
      x: 0,
      y: -1
    },
    {
      x: -1,
      y: 0
    },
    {
      x: 0,
      y: 0
    },
    {
      x: +1,
      y: 0
    },
    {
      x: 0,
      y: +1
    }
  ];

  return TiledActionProvider;

}).call(this);

return(TiledActionProvider);});